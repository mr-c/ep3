#!/usr/bin/env ruby
require 'optparse'
require 'json'
require 'yaml'

def jobinfo(start, end_, dir)
    inputs = open(File.join(dir, 'cwl.inputs.json')) { |f|
        JSON.load(f)
    }
    outputs = open(File.join(dir, 'cwl.output.json')) { |f|
        JSON.load(f)
    }
    cid = open(File.join(dir, 'cid')).readlines.join
    runtime = JSON.parse(`docker info --format '{{json .}}' | jq '{ "running_containers": .ContainerRunning, "server_version": .ServerVersion, "storage_driver": .Driver, "number_of_cpu": .NCPU, "total_memory": .MemTotal }'`)
    process = JSON.parse(`docker inspect #{cid} | jq "{ \"id\": \\"#{cid}\\", \"image\": .[0].Config.Image, \"cmd\": .[0].Config.Cmd, \"status\": .[0].State.Status, \"start_time\": .[0].State.StartedAt, \"end_time\": .[0].State.FinishedAt, \"exit_code\": .[0].State.ExitCode }"`)
    process['cmd'] = process['cmd'].join(' ')
    resource = if File.exist?(File.join(dir, 'Allocation.resource'))
                  open(File.join(dir, 'Allocation.resource')) { |f|
                      JSON.load(f)
                  }
               else
                  {}
               end
    platform = if resource.fetch('properties', {}).fetch('provider', '') == 'aws'
                  props = resource['properties']
                  {
                    hostname: nil,
                    ncpu_cores: props['ncores'],
                    total_memory: props['memory']*(1024**3),
                    disk_size: props['storage']*(1024**2),
                    ec2_ami_id: nil,
                    ec2_instance_type: props['flavor'],
                    ec2_region: props['region'],
                  }
               else
                  {
                    hostname: nil,
                    ncpu_cores: nil,
                    total_memory: nil,
                    disk_size: nil,
                  }
               end
    status = if open(File.join(dir, 'ExecutionState')).readlines.join.chomp == 'success'
                'success'
             else
                'failed'
             end
    {
        step_name: File.basename(File.absolute_path(File.join(dir, '..'))),
        start_date: start,
        end_date: end_,
        cwl_file: 'job.cwl',
        tool_status: status,
        inputs: inputs,
        outputs: outputs,
        container: {
            process: process,
            runtime: runtime,
        },
        platform: platform,
    }
end

def workflowinfo(start, end_, dir)
    inputs = open(File.join(dir, 'inputs.json')) { |f|
        JSON.load(f)
    }
    outputs = open(File.join(dir, 'cwl.output.json')) { |f|
        JSON.load(f)
    }
    {
        cwl_metrics_version: '0.1.18',
        metrics_generator: {
            name: 'ep3-log-generator',
            version: '0.0'
        },
        workflow: {
            start_date: start,
            end_date: end_,
            cwl_file: 'job.cwl',
            genome_version: nil,
            inputs: inputs,
            outputs: outputs,
        },
        steps: Hash[
            Dir.glob('*', base: File.join(dir, '..', 'steps')).map{ |step|
                [
                    step,
                    open(File.join(dir, "#{step}_metrics.json")) { |f|
                        JSON.load(f)
                    }
                ]
            }
        ]
    }
end

if $0 == __FILE__
    Signal.trap(:INT, 'IGNORE')
    opt = OptionParser.new
    opt.banner = "Usage: #{$0} <start> <end> <basedir>"
    opt.parse!(ARGV)

    unless ARGV.length == 3
        puts opt.help
        exit
    end

    start, end_, dir = ARGV
    cwl = YAML.load_file(File.join(dir, '..', 'cwl', 'job.cwl'))
    metrics = case cwl['class']
              when 'CommandLineTool'
                jobinfo(start, end_, dir)
              when 'Workflow'
                workflowinfo(start, end_, dir)
              end
    puts JSON.dump(metrics)
end

#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require 'net/http'
require_relative '../runtime/inspector'

def parse_option_file(file)
  if File.exist? file
    open(file) { |f|
      JSON.load(f)
    }
  else
    {}
  end
end

def to_reconf_params(cwl_file, params_file, id)
  cwl = CommonWorkflowLanguage.load_file(cwl_file)
  params = open(params_file) { |f|
    JSON.load(f)
  }
  {
    input_params: Hash[params.keep_if{ |k, v|
      v.instance_of?(Hash) and v.fetch('class', '') == 'File'
    }.map{ |k, v|
      [k, v['size']/(1024.0**3)]
    }],
    tool_id: get_requirement(cwl, 'DockerRequirement').dockerPull,
    next_step_uuid: nil,
    workflow_name: 'job.cwl',
    workflow_invocation_id: id,
  }
end

def post_request(endpoint, params)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  response = http.post(uri.path, JSON.dump(params), headers)

  raise "Error in creation: #{response.body}" if response.code != '201'

  JSON.load(response.body)
  # {
  #   req_id: xxx
  # }
end

def poll(as_server, ids, timeout)
  uri = URI.parse(ra_server)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  start = Time.now
  ids.map{ |id|
    json = nil
    target = URI.parse("#{ra_server}/status/#{id}")
    (timeout/10.0).ceil.times{
      response = http.get(target.path, headers)
      json = JSON.load(response.body)
      if response.code == '200'
        break if json['done'] and json['result']['success']
      else
        warn "Warning: code: #{response.code}, body: #{JSON.dump(response.body)}"
      end

      unless json['result']['success']
        warn "Error: request failed"
        break
      end
      break if Time.now-start > timeout
      sleep 10
    }
    # body = {
    #   done: false,
    #   instance_name: "i3",
    #   properties: {
    #     cost: 0.0059,
    #     flavor: "t2.nano",
    #     memory: 0.0,
    #     ncores: 1,
    #     provider: "aws",
    #     region: "US West (Oregon)",
    #     storage: 8
    #   },
    #   request_id: "xyz",
    #   result: {
    #     endpoint: "172.30.2.60",
    #     error_message: "",
    #     success: true
    #   }
    # }
    [json['instance_name'], json]
  }
end

if $0 == __FILE__
  options = {
    'as': nil,
  }
  timeout = 10*60 # 10 min.
  dry_run = false
  nowait = false
  opt_file = '.reconf.json'
  opt = OptionParser.new
  opt.banner = "Usage: #{$0} [options] cwl params plan-result"
  # common options
  # cwl: A file name for tool definition
  # params: A file name for input parameters
  # user-requirements: A file name for user requirements
  opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") { |to|
    timeout = to.to_i
  }
  opt.on('--config=FILE',
         "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") { |f|
    unless File.exist? f
      warn "File not found: #{f}"
      exit 1
    end
    opt_file = f
  }
  opt.on('--dry-run', 'Print parameters') {
    dry_run = true
  }
  opt.on('--nowait', 'Post parameters and immediately exit') {
    nowait = true
  }

  # reconf allocator specific options
  opt.on('--as-endpoint=AS', 'An endpoint to an application scheduler') { |as|
    options['as'] = as
  }

  opt.parse!(ARGV)
  unless ARGV.length == 3
    puts opt.help
    exit
  end

  cwl, params, plan = *ARGV

  raise "File not found: #{cwl}" unless File.exist? cwl
  raise "File not found: #{params}" unless File.exist? params
  raise "File not found: #{plan}" unless File.exist? plan

  options = parse_option_file(opt_file).merge(options)
  as_server = options['as']

  invocation_id = open(plan) { |f|
    JSON.load(f)
  }['invocation_id']

  ps = to_reconf_params(cwl, params, invocation_id)
  if dry_run
    puts JSON.dump(ps)
    exit
  end

  body = post_request("#{as_server}/reconf", ps)
  if nowait
    puts JSON.dump({
      invocation_id: invocation_id,
      reconf_params: ps,
      post_response: body,
    })
    exit
  end
  id = body['req_id']
  # TODO
  allocated = poll("#{as_server}/status/#{id}", timeout)
  puts JSON.dump(Hash[allocated])
end

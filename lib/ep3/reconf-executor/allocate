#!/usr/bin/env ruby
# coding: utf-8
require 'optparse'
require 'json'
require 'net/http'
require_relative '../runtime/inspector'

def parse_option_file(file)
  if File.exist? file
    open(file) { |f|
      JSON.load(f)
    }
  else
    {}
  end
end

def to_reconf_params(cwl_file, params_file)
  cwl = CommonWorkflowLanguage.load_file(cwl_file)
  params = open(params_file) { |f|
    JSON.load(f)
  }
  {
    tool_id: get_requirement(cwl, 'DockerRequirement').dockerPull,
    input_params: Hash[params.keep_if{ |k, v|
      v.instance_of?(Hash) and v.fetch('class', '') == 'File'
    }.map{ |k, v|
      [k, v['size']/(1024.0**3)]
    }]
  }
end

def post_request(endpoint, params)
  uri = URI.parse(endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  response = http.post(uri.path, JSON.dump(params), headers)

  raise "Error in creation: #{response.body}" if response.code != '201'

  JSON.load(response.body)
  # {
  #   req_id: xxx
  # }
end

def poll(as_server, ids, timeout)
  uri = URI.parse(ra_server)
  http = Net::HTTP.new(uri.host, uri.port)
  headers = { 'Content-Type' => 'application/json' }
  start = Time.now
  ids.map{ |id|
    json = nil
    target = URI.parse("#{ra_server}/status/#{id}")
    (timeout/10.0).ceil.times{
      response = http.get(target.path, headers)
      json = JSON.load(response.body)
      if response.code == '200'
        break if json['done'] and json['result']['success']
      else
        warn "Warning: code: #{response.code}, body: #{JSON.dump(response.body)}"
      end

      unless json['result']['success']
        warn "Error: request failed"
        break
      end
      break if Time.now-start > timeout
      sleep 10
    }
    # body = {
    #   done: false,
    #   instance_name: "i3",
    #   properties: {
    #     cost: 0.0059,
    #     flavor: "t2.nano",
    #     memory: 0.0,
    #     ncores: 1,
    #     provider: "aws",
    #     region: "US West (Oregon)",
    #     storage: 8
    #   },
    #   request_id: "xyz",
    #   result: {
    #     endpoint: "172.30.2.60",
    #     error_message: "",
    #     success: true
    #   }
    # }
    [json['instance_name'], json]
  }
end

if $0 == __FILE__
  options = {
    'as' nil,
  }
  timeout = 10*60 # 10 min.
  opt_file = '.reconf.json'
  opt = OptionParser.new
  opt.banner = "Usage: #{$0} [options] cwl params"
  # common options
  # cwl: A file name for tool definition
  # params: A file name for input parameters
  # user-requirements: A file name for user requirements
  opt.on('--timeout=TO', "Timeout in seconds (default: #{timeout} sec.)") { |to|
    timeout = to.to_i
  }
  opt.on('--config=FILE',
         "A file name for configuration params such as ra and ms endpoints (default: #{opt_file})") { |f|
    unless File.exist? f
      warn "File not found: #{f}"
      exit 1
    end
    opt_file = f
  }

  # reconf allocator specific options
  opt.on('--as-endpoint=AS', 'An endpoint to an application scheduler') { |as|
    options['as'] = as
  }

  opt.parse!(ARGV)
  unless ARGV.length == 2
    puts opt.help
    exit
  end

  cwl, params = *ARGV

  raise "File not found: #{cwl}" unless File.exist? cwl
  raise "File not found: #{params}" unless File.exist? params

  options = parse_option_file(opt_file).merge(options)
  as_server = options['as']

  ps = to_reconf_params(cwl, params)
  body = post_request("#{as_server}/reconf", ps)
  puts JSON.dump(body)
#  id = body['req_id']
#  allocated = poll(as_server, body.map{ |k, v| v['request_id'] }, timeout)
#  puts JSON.dump(Hash[allocated])
end
